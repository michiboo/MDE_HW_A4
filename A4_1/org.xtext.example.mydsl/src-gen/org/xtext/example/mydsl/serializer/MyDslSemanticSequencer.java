/*
 * generated by Xtext 2.25.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import cryptoExchangePackage.Account;
import cryptoExchangePackage.CryptoExchangePackagePackage;
import cryptoExchangePackage.Order;
import cryptoExchangePackage.SavingOrder;
import cryptoExchangePackage.SubSystem;
import cryptoExchangePackage.Token;
import cryptoExchangePackage.TokenBalance;
import cryptoExchangePackage.TokenNetwork;
import cryptoExchangePackage.TokenPair;
import cryptoExchangePackage.TransferRequest;
import cryptoExchangePackage.cryptoExchange;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CryptoExchangePackagePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CryptoExchangePackagePackage.ACCOUNT:
				sequence_Account(context, (Account) semanticObject); 
				return; 
			case CryptoExchangePackagePackage.ORDER:
				sequence_Order(context, (Order) semanticObject); 
				return; 
			case CryptoExchangePackagePackage.SAVING_ORDER:
				sequence_SavingOrder(context, (SavingOrder) semanticObject); 
				return; 
			case CryptoExchangePackagePackage.SUB_SYSTEM:
				sequence_SubSystem(context, (SubSystem) semanticObject); 
				return; 
			case CryptoExchangePackagePackage.TOKEN:
				sequence_Token(context, (Token) semanticObject); 
				return; 
			case CryptoExchangePackagePackage.TOKEN_BALANCE:
				sequence_TokenBalance(context, (TokenBalance) semanticObject); 
				return; 
			case CryptoExchangePackagePackage.TOKEN_NETWORK:
				sequence_TokenNetwork(context, (TokenNetwork) semanticObject); 
				return; 
			case CryptoExchangePackagePackage.TOKEN_PAIR:
				sequence_TokenPair(context, (TokenPair) semanticObject); 
				return; 
			case CryptoExchangePackagePackage.TRANSFER_REQUEST:
				sequence_TransferRequest(context, (TransferRequest) semanticObject); 
				return; 
			case CryptoExchangePackagePackage.CRYPTO_EXCHANGE:
				sequence_cryptoExchange(context, (cryptoExchange) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Account returns Account
	 *
	 * Constraint:
	 *     ((TokensBalance+=TokenBalance TokensBalance+=TokenBalance*)? (transferRequest+=TransferRequest transferRequest+=TransferRequest*)?)
	 */
	protected void sequence_Account(ISerializationContext context, Account semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Order returns Order
	 *
	 * Constraint:
	 *     (
	 *         Price=EFloat 
	 *         Amount=EFloat 
	 *         leverage=LeverageType? 
	 *         Type=OrderType? 
	 *         account=[Account|EString] 
	 *         TokenPair=[TokenPair|EString]
	 *     )
	 */
	protected void sequence_Order(ISerializationContext context, Order semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SavingOrder returns SavingOrder
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         Amount=EFloat 
	 *         MatureDate=EDate? 
	 *         Interest=EDouble 
	 *         account=[Account|EString] 
	 *         Token=[Token|EString]
	 *     )
	 */
	protected void sequence_SavingOrder(ISerializationContext context, SavingOrder semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SubSystem returns SubSystem
	 *
	 * Constraint:
	 *     (
	 *         name=SubSystemName 
	 *         (accounts+=Account accounts+=Account*)? 
	 *         (TokenPairs+=TokenPair TokenPairs+=TokenPair*)? 
	 *         (Orders+=Order Orders+=Order*)? 
	 *         (SavingOrders+=SavingOrder SavingOrders+=SavingOrder*)?
	 *     )
	 */
	protected void sequence_SubSystem(ISerializationContext context, SubSystem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TokenBalance returns TokenBalance
	 *
	 * Constraint:
	 *     (name=EString balance=EFloat Token=[Token|EString])
	 */
	protected void sequence_TokenBalance(ISerializationContext context, TokenBalance semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CryptoExchangePackagePackage.Literals.TOKEN_BALANCE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CryptoExchangePackagePackage.Literals.TOKEN_BALANCE__NAME));
			if (transientValues.isValueTransient(semanticObject, CryptoExchangePackagePackage.Literals.TOKEN_BALANCE__BALANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CryptoExchangePackagePackage.Literals.TOKEN_BALANCE__BALANCE));
			if (transientValues.isValueTransient(semanticObject, CryptoExchangePackagePackage.Literals.TOKEN_BALANCE__TOKEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CryptoExchangePackagePackage.Literals.TOKEN_BALANCE__TOKEN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTokenBalanceAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTokenBalanceAccess().getBalanceEFloatParserRuleCall_4_0(), semanticObject.getBalance());
		feeder.accept(grammarAccess.getTokenBalanceAccess().getTokenTokenEStringParserRuleCall_6_0_1(), semanticObject.eGet(CryptoExchangePackagePackage.Literals.TOKEN_BALANCE__TOKEN, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TokenNetwork returns TokenNetwork
	 *
	 * Constraint:
	 *     (name=EString chainID=EInt RPC=EString?)
	 */
	protected void sequence_TokenNetwork(ISerializationContext context, TokenNetwork semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TokenPair returns TokenPair
	 *
	 * Constraint:
	 *     (price=EFloat TokenA=[Token|EString] TokenB=[Token|EString])
	 */
	protected void sequence_TokenPair(ISerializationContext context, TokenPair semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CryptoExchangePackagePackage.Literals.TOKEN_PAIR__PRICE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CryptoExchangePackagePackage.Literals.TOKEN_PAIR__PRICE));
			if (transientValues.isValueTransient(semanticObject, CryptoExchangePackagePackage.Literals.TOKEN_PAIR__TOKEN_A) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CryptoExchangePackagePackage.Literals.TOKEN_PAIR__TOKEN_A));
			if (transientValues.isValueTransient(semanticObject, CryptoExchangePackagePackage.Literals.TOKEN_PAIR__TOKEN_B) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CryptoExchangePackagePackage.Literals.TOKEN_PAIR__TOKEN_B));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTokenPairAccess().getPriceEFloatParserRuleCall_3_0(), semanticObject.getPrice());
		feeder.accept(grammarAccess.getTokenPairAccess().getTokenATokenEStringParserRuleCall_5_0_1(), semanticObject.eGet(CryptoExchangePackagePackage.Literals.TOKEN_PAIR__TOKEN_A, false));
		feeder.accept(grammarAccess.getTokenPairAccess().getTokenBTokenEStringParserRuleCall_7_0_1(), semanticObject.eGet(CryptoExchangePackagePackage.Literals.TOKEN_PAIR__TOKEN_B, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Token returns Token
	 *
	 * Constraint:
	 *     (name=EString address=EString? decimal=EInt TokenNetwork=[TokenNetwork|EString])
	 */
	protected void sequence_Token(ISerializationContext context, Token semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TransferRequest returns TransferRequest
	 *
	 * Constraint:
	 *     (ID=EString type=TransferType? amount=EFloat Token=[Token|EString] Destination=[Account|EString])
	 */
	protected void sequence_TransferRequest(ISerializationContext context, TransferRequest semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     cryptoExchange returns cryptoExchange
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         IP=EString? 
	 *         DomainName=EString? 
	 *         SubSystem+=SubSystem 
	 *         SubSystem+=SubSystem* 
	 *         Tokens+=Token 
	 *         Tokens+=Token* 
	 *         TokenNetworks+=TokenNetwork 
	 *         TokenNetworks+=TokenNetwork*
	 *     )
	 */
	protected void sequence_cryptoExchange(ISerializationContext context, cryptoExchange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
